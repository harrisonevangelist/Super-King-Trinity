<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
Â  <title>Superking Trinity Unified Interface</title>
Â  <style>
Â  Â  body { 
        background: #111; 
        color: #eee; 
        font-family: sans-serif; 
        text-align: center; 
        padding: 20px; 
    }
Â  Â  canvas { 
        background: #222; 
        display: block; 
        margin: 20px auto; 
        border: 2px solid #0f0; 
    }
Â  Â  /* Top Board/Log Styles */
Â  Â  #log, #position, #verseDisplay { 
        margin: 20px auto; 
        font-size: 18px; 
        white-space: pre-line; 
        text-align: left; 
        max-width: 420px; 
    }
Â  Â  button, input { 
        margin: 8px; 
        padding: 10px 20px; 
        font-size: 16px; 
    }
    /* Separate styles for FEN inputs to prevent conflict */
    #topFenInput {
        width: 90%;
        max-width: 400px;
    }
    #fenInput { /* TARGETED BY THE NEW LOGIC (aifen1) */
        width: 100%;
        max-width: 600px;
        box-sizing: border-box;
    }
Â  Â  #verseDisplay { 
        color: #0f0; 
        font-size: 20px; 
        border-bottom: 2px solid #0f0;
        padding-bottom: 10px;
    }
    /* Bottom AI Interface Styles */
    .section {
        margin: 20px auto;
        padding: 10px;
        border: 1px solid #333;
        border-radius: 8px;
        max-width: 800px;
        text-align: left;
    }
    /* Add a divider between the two main components */
    #interface-divider {
        margin: 50px auto;
        height: 4px;
        background: #0f0;
        width: 90%;
        max-width: 800px;
    }
Â  </style>
Â  <link rel="stylesheet" href="styles.css"> </head>
<body>

Â  <h1>ðŸ‘‘ Superking Trinity Chessboard</h1>
Â  <canvas id="boardCanvas" width="480" height="480"></canvas>

Â  Â  <div>
Â  Â  <button onclick="top_finishSuperkingMove()">Finish Move</button>
Â  Â  <button onclick="top_takeBackMove()">Take Back Move</button>
Â  Â  <button onclick="top_showPosition('w')">Show FEN w</button>
Â  Â  <button onclick="top_showPosition('b')">Show FEN b</button>
Â  Â  <button onclick="top_copyFENButtonAction()">Copy Full FEN (w)</button>
    <button onclick="top_copyLog()">Copy Log</button>
Â  </div>

Â  <div>
Â  Â  <input id="topFenInput" placeholder="Paste FEN-style position here for TOP board">
Â  Â  <button onclick="top_loadPosition()">Load Position</button>
Â  </div>

Â  <div id="log">Move Log:</div>
Â  <div id="position">Board Position:</div>
Â  <div id="verseDisplay"></div>

Â  <div id="interface-divider"></div>

Â  Â  <h2>SKT Board Interface</h2>

Â  <div class="section">
Â  Â  <label for="fenInput"><strong>FEN Input (Bottom Interface / aifen1):</strong></label><br>
Â  Â  Â  Â  <textarea id="fenInput" rows="2" cols="80" placeholder="Paste FEN here..."></textarea>
Â  </div>

Â  <div class="section" style="text-align: center;">
Â  Â  <button onclick="bestMove()">Best Move</button>
Â  Â  <button onclick="bestMoveTwoPlies()">Best Move Two Plies</button>
Â  Â  <button onclick="loadFEN()">Load FEN</button>
Â  Â  <button onclick="applyBestMove()">Apply Best Move</button>
Â  Â  <button onclick="aiVsAiFifty(50)">AI vs AI 50 Cycles</button>
Â  Â  <button onclick="transferFinalFEN()">Transfer Final FEN</button>
Â  </div>

Â  <div class="section">
Â  Â  <label for="bestMoveDisplay"><strong>Best Move:</strong></label><br>
Â  Â  <div id="bestMoveDisplay" style="white-space: pre-wrap; min-height: 20px; padding: 10px; background: #f0f0f0; border-radius: 4px; color: #111;"></div>
Â  </div>

Â  <div class="section">
Â  Â  <label for="output"><strong>Path Output:</strong></label><br>
Â  Â  <textarea id="output" rows="10" cols="80" readonly></textarea>
Â  Â  </div>

Â  <div class="section">
Â  Â  <label for="targets"><strong>Targets:</strong></label><br>
Â  Â  <pre id="targets" style="background: #f0f0f0; padding: 10px; border-radius: 4px; color: #111;"></pre>
Â  Â  </div>

Â  <div class="section">
Â  Â  <label for="readBoardOutput"><strong>Read Board FEN:</strong></label><br>
Â  Â  <textarea id="readBoardOutput" rows="2" cols="80"></textarea>
Â  </div>

Â  <div class="section">
Â  Â  <label for="captureMoveOutput"><strong>Captured Move:</strong></label><br>
Â  Â  <textarea id="captureMoveOutput" rows="2" cols="80" readonly></textarea>
Â  Â  <label for="captureFENOutput"><strong>Captured FEN (Before Move):</strong></label><br>
Â  Â  <textarea id="captureFENOutput" rows="2" cols="80" readonly></textarea>
Â  </div>

Â  <div class="section">
Â  Â  <label for="appliedFENOutput"><strong>Applied Move FEN (After Move):</strong></label><br>
Â  Â  <textarea id="appliedFENOutput" rows="2" cols="80" readonly></textarea>
Â  </div>

Â  <div class="section">
Â  Â  <label for="finalFENOutput"><strong>Final FEN After Applying Best Move:</strong></label><br>
Â  Â  <textarea id="finalFENOutput" rows="2" cols="80" readonly></textarea>
Â  </div>

Â  <div class="section" style="text-align: center;">
Â  Â  <strong>Board:</strong><br><br>
Â  Â  <table id="board"></table>
Â  </div>

Â  <div class="section">
Â  Â  <label for="moveLogs"><strong>Move Logs (Cycles):</strong></label><br>
Â  Â  <textarea id="moveLogs" rows="12" cols="80" readonly></textarea>
Â  Â  <div style="text-align: right; margin-top: 5px;">
Â  Â  Â  <button onclick="copyMoveLogs(event)">Copy Move Logs</button>
Â  Â  </div>
Â  </div>

Â  Â  <script>
Â  Â  const canvas = document.getElementById("boardCanvas");
Â  Â  const ctx = canvas.getContext("2d");
Â  Â  const boardSize = 8;
Â  Â  const squareSize = canvas.width / boardSize;

Â  Â  let board = [];
Â  Â  let moveLog = [];
Â  Â  let history = [];
Â  Â  let selected = null;
Â  Â  let superkingPath = [];
Â  Â  let lastMove = null;

Â  Â  const verses = [
Â  Â  Â  "John 3:16 For God so loved the world, that he gave his only begotten Son, that whosoever believeth in him should not perish, but have everlasting life.",
Â  Â  Â  "1 John 5:12 He that hath the Son hath life; and he that hath not the Son of God hath not life.",
Â  Â  Â  "Matthew 28:19 Go ye therefore, and teach all nations, baptizing them in the name of the Father, and of the Son, and of the Holy Ghost."
Â  Â  ];
Â  Â  let verseIndex = 0;

Â  Â  /* --- Piece Mappings & UTILS (unchanged) --- */

Â  Â  // Piece Emojis (Symbol to FEN)
Â  Â  const pieceToFENMap = {
Â  Â  Â  'â™™': 'P', 'â™˜': 'N', 'â™—': 'B', 'â™–': 'R', 'â™•': 'Q', 'â™”': 'K',
Â  Â  Â  'â™Ÿ': 'p', 'â™ž': 'n', 'â™': 'b', 'â™œ': 'r', 'â™›': 'q', 'k': 'k',
Â  Â  Â  'ðŸ‘‘': 'S', // White Superking
Â  Â  Â  'â™š': 's'Â  // Black Superking (MODIFIED)
Â  Â  };

Â  Â  // FEN to Piece Emojis (FEN to Symbol)
Â  Â  const FENtoPieceMap = {
Â  Â  Â  'P': 'â™™', 'N': 'â™˜', 'B': 'â™—', 'R': 'â™–', 'Q': 'â™•', 'K': 'â™”', 'S': 'ðŸ‘‘', // White Superking
Â  Â  Â  'p': 'â™Ÿ', 'n': 'â™ž', 'b': 'â™', 'r': 'â™œ', 'q': 'â™›', 'k': 'â™š', 's': 'â™š' // Black Superking (MODIFIED)
Â  Â  };
Â  Â Â 
Â  Â  // Promotion maps
Â  Â  const whitePromotionMap = { 'Q': 'â™•', 'R': 'â™–', 'B': 'â™—', 'N': 'â™˜' };
Â  Â  const blackPromotionMap = { 'Q': 'â™›', 'R': 'â™œ', 'B': 'â™', 'N': 'â™ž' };

Â  Â  function top_pieceToFEN(piece) {
Â  Â  Â  return pieceToFENMap[piece] || '';
Â  Â  }

Â  Â  function top_FENtoPiece(char) {
Â  Â  Â  return FENtoPieceMap[char] || '';
Â  Â  }

Â  Â  function top_isWhite(piece) {
Â  Â  Â  // Check if the piece is a white symbol (White Superking is 'ðŸ‘‘')
Â  Â  Â  return 'â™™â™˜â™—â™–â™•â™”ðŸ‘‘'.includes(piece);
Â  Â  }
Â  Â Â 
Â  Â  function top_copyBoard(src) {
Â  Â  Â  return src.map(row => row.slice());
Â  Â  }

Â  Â  function top_coordsToAlgebraic(r, c) {
Â  Â  Â  return String.fromCharCode(97 + c) + (8 - r);
Â  Â  }
Â  Â Â 
Â  Â  function top_parseMove(moveStr) {
Â  Â  Â  Â  // Example: "â™™e2e4" â†’ ['â™™', 'e2', 'e4']
Â  Â  Â  Â  if (moveStr.startsWith("S") || moveStr.startsWith("s")) return [moveStr.slice(0, 1), moveStr.slice(1)];
Â  Â  Â  Â  const piece = moveStr[0];
Â  Â  Â  Â  const from = moveStr.slice(1, 3);
Â  Â  Â  Â  const to = moveStr.slice(3, 5);
Â  Â  Â  Â  const promotion = moveStr.length > 5 ? moveStr.slice(5, 6) : '';
Â  Â  Â  Â  return [piece, from, to, promotion];
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Prompts the user for a promotion choice (Q, R, B, N)
Â  Â  Â */
Â  Â  function top_handlePawnPromotion(r, c, piece) {
Â  Â  Â  Â  const isPawn = piece === 'â™™' || piece === 'â™Ÿ';
Â  Â  Â  Â  if (!isPawn) return piece;

Â  Â  Â  Â  const isWhitePiece = top_isWhite(piece);
Â  Â  Â  Â  const lastRank = isWhitePiece ? 0 : boardSize - 1;

Â  Â  Â  Â  if (r === lastRank) {
Â  Â  Â  Â  Â  Â  let choice = prompt("Pawn Promotion! Choose a piece: Q (Queen), R (Rook), B (Bishop), or N (Knight)").toUpperCase();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // Validate and convert choice
Â  Â  Â  Â  Â  Â  if (isWhitePiece) {
Â  Â  Â  Â  Â  Â  Â  Â  return whitePromotionMap[choice] || 'â™•'; // Default to Queen
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  return blackPromotionMap[choice] || 'â™›'; // Default to Queen
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return piece;
Â  Â  }

Â  Â  /* --- Piece Movement Logic (unchanged) --- */
Â  Â Â 
Â  Â  function top_getRookMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const pieceColor = top_isWhite(b[r][c]);
Â  Â  Â  Â  const directions = [[-1, 0], [1, 0], [0, -1], [0, 1]];Â 

Â  Â  Â  Â  for (const [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  for (let i = 1; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const nr = r + dr * i;
Â  Â  Â  Â  Â  Â  Â  Â  const nc = c + dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  if (nr < 0 || nr >= boardSize || nc < 0 || nc >= boardSize) break;

Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (target === '') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc });
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (top_isWhite(target) !== pieceColor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc }); // Capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // Blocked
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }

Â  Â  function top_getBishopMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const pieceColor = top_isWhite(b[r][c]);
Â  Â  Â  Â  const directions = [[-1, -1], [-1, 1], [1, -1], [1, 1]];

Â  Â  Â  Â  for (const [dr, dc] of directions) {
Â  Â  Â  Â  Â  Â  for (let i = 1; i < boardSize; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  const nr = r + dr * i;
Â  Â  Â  Â  Â  Â  Â  Â  const nc = c + dc * i;
Â  Â  Â  Â  Â  Â  Â  Â  if (nr < 0 || nr >= boardSize || nc < 0 || nc >= boardSize) break;

Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (target === '') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc });
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (top_isWhite(target) !== pieceColor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc }); // Capture
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break; // Blocked
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }
Â  Â Â 
Â  Â  function top_getQueenMoves(b, r, c) {
Â  Â  Â  Â  return [
Â  Â  Â  Â  Â  Â  ...top_getRookMoves(b, r, c),
Â  Â  Â  Â  Â  Â  ...top_getBishopMoves(b, r, c)
Â  Â  Â  Â  ];
Â  Â  }
Â  Â Â 
Â  Â  function top_getKnightMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const pieceColor = top_isWhite(b[r][c]);
Â  Â  Â  Â  const deltas = [
Â  Â  Â  Â  Â  Â  [-2, -1], [-2, 1], [-1, -2], [-1, 2],
Â  Â  Â  Â  Â  Â  [1, -2], [1, 2], [2, -1], [2, 1]
Â  Â  Â  Â  ];
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (const [dr, dc] of deltas) {
Â  Â  Â  Â  Â  Â  const nr = r + dr;
Â  Â  Â  Â  Â  Â  const nc = c + dc;
Â  Â  Â  Â  Â  Â  if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (target === '' || top_isWhite(target) !== pieceColor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc });
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }
Â  Â Â 
Â  Â  function top_getKingMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const pieceColor = top_isWhite(b[r][c]);
Â  Â  Â  Â  for (let dr = -1; dr <= 1; dr++) {
Â  Â  Â  Â  Â  Â  for (let dc = -1; dc <= 1; dc++) {
Â  Â  Â  Â  Â  Â  Â  Â  if (dr === 0 && dc === 0) continue;
Â  Â  Â  Â  Â  Â  Â  Â  const nr = r + dr;
Â  Â  Â  Â  Â  Â  Â  Â  const nc = c + dc;
Â  Â  Â  Â  Â  Â  Â  Â  if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (target === '' || top_isWhite(target) !== pieceColor) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }

Â  Â  function top_getPawnMoves(b, r, c) {
Â  Â  Â  Â  const moves = [];
Â  Â  Â  Â  const piece = b[r][c];
Â  Â  Â  Â  const isWhitePiece = top_isWhite(piece);
Â  Â  Â  Â  const dir = isWhitePiece ? -1 : 1;
Â  Â  Â  Â  const startRow = isWhitePiece ? 6 : 1;
Â  Â  Â  Â  const finalRank = isWhitePiece ? 0 : boardSize - 1;

Â  Â  Â  Â  // 1. One square forward
Â  Â  Â  Â  const nr1 = r + dir;
Â  Â  Â  Â  if (nr1 >= 0 && nr1 < boardSize && b[nr1][c] === '') {
Â  Â  Â  Â  Â  Â  moves.push({ r: nr1, c: c, promote: nr1 === finalRank });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  // 2. Two squares forward from starting rank
Â  Â  Â  Â  Â  Â  const nr2 = r + 2 * dir;
Â  Â  Â  Â  Â  Â  if (r === startRow && nr2 >= 0 && nr2 < boardSize && b[nr2][c] === '') {
Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr2, c: c });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // 3. Diagonal captures & Promotion captures
Â  Â  Â  Â  for (let dc of [-1, 1]) {
Â  Â  Â  Â  Â  Â  const nr = r + dir;
Â  Â  Â  Â  Â  Â  const nc = c + dc;
Â  Â  Â  Â  Â  Â  if (nr >= 0 && nr < boardSize && nc >= 0 && nc < boardSize) {
Â  Â  Â  Â  Â  Â  Â  Â  const target = b[nr][nc];
Â  Â  Â  Â  Â  Â  Â  Â  if (target !== '' && top_isWhite(target) !== isWhitePiece) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc, capture: true, promote: nr === finalRank });
Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  // 4. En passant (based on the last move)
Â  Â  Â  Â  Â  Â  Â  Â  if (lastMove && r === (isWhitePiece ? 3 : 4)) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const [, fromAlg, toAlg] = top_parseMove(lastMove);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const toCol = toAlg.charCodeAt(0) - 97;

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Check if opponent just moved a pawn two squares next to the current pawn
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const enemyPawn = isWhitePiece ? 'â™Ÿ' : 'â™™';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  if (b[r][nc] === enemyPawn) { // Check if an enemy pawn is *beside* the capturing pawn
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Note: A real implementation would also check if the *last move* was a two-square advance by that pawn
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  moves.push({ r: nr, c: nc, enPassant: true, captureCol: nc });
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return moves;
Â  Â  }

Â  Â  function top_getValidMoves(r, c) {
Â  Â  Â  Â  const piece = board[r][c];
Â  Â  Â  Â  const pieceFEN = top_pieceToFEN(piece).toUpperCase(); // Use FEN for switch

Â  Â  Â  Â  let moves = [];
Â  Â  Â  Â  switch (pieceFEN) {
Â  Â  Â  Â  Â  Â  case 'R': moves = top_getRookMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'N': moves = top_getKnightMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'B': moves = top_getBishopMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'Q': moves = top_getQueenMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'K': moves = top_getKingMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  case 'S': moves = top_getKingMoves(board, r, c); break; // Superking follows King's simple move rules for 1-square moves
Â  Â  Â  Â  Â  Â  case 'P': moves = top_getPawnMoves(board, r, c); break;
Â  Â  Â  Â  Â  Â  default: return [];
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Return only the basic coordinates
Â  Â  Â  Â  return moves.map(m => ({ r: m.r, c: m.c }));
Â  Â  }

Â  Â  /* --- Drawing and Board State (unchanged) --- */

Â  Â  function top_drawBoard() {
Â  Â  Â  ctx.clearRect(0, 0, canvas.width, canvas.height);

Â  Â  Â  for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  for (let c = 0; c < boardSize; c++) {
Â  Â  Â  Â  Â  ctx.fillStyle = (r + c) % 2 === 0 ? "#555" : "#777";
Â  Â  Â  Â  Â  ctx.fillRect(c * squareSize, r * squareSize, squareSize, squareSize);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // Selected square highlight
Â  Â  Â  if (selected) {
Â  Â  Â  Â  ctx.fillStyle = "rgba(255,255,0,0.4)";
Â  Â  Â  Â  ctx.fillRect(selected.c * squareSize, selected.r * squareSize, squareSize, squareSize);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Superking path highlight
Â  Â  Â  superkingPath.forEach((p, i) => {
Â  Â  Â  Â  Â  ctx.fillStyle = i === superkingPath.length - 1 ? "rgba(0, 255, 0, 0.7)" : "rgba(0, 255, 0, 0.3)";
Â  Â  Â  Â  Â  ctx.fillRect(p.c * squareSize, p.r * squareSize, squareSize, squareSize);
Â  Â  Â  });

Â  Â  Â  // Draw pieces
Â  Â  Â  ctx.font = "46px Arial";Â 
Â  Â  Â  ctx.textAlign = "center";
Â  Â  Â  ctx.textBaseline = "middle";

Â  Â  Â  for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  for (let c = 0; c < boardSize; c++) {
Â  Â  Â  Â  Â  const piece = board[r][c];
Â  Â  Â  Â  Â  if (piece) {
Â  Â  Â  Â  Â  Â  // top_isWhite is correct for all pieces including 'â™š'
Â  Â  Â  Â  Â  Â  ctx.fillStyle = top_isWhite(piece) ? "#fff" : "#000";Â 
Â  Â  Â  Â  Â  Â  ctx.fillText(piece, c * squareSize + squareSize / 2, r * squareSize + squareSize / 2 + 2);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  /* --- EVENT HANDLERS (unchanged) --- */

Â  Â  canvas.addEventListener("click", (e) => {
Â  Â  Â  const rect = canvas.getBoundingClientRect();
Â  Â  Â  const x = e.clientX - rect.left;
Â  Â  Â  const y = e.clientY - rect.top;
Â  Â  Â  const c = Math.floor(x / squareSize);
Â  Â  Â  const r = Math.floor(y / squareSize);
Â  Â  Â  const clicked = board[r][c];

Â  Â  Â  if (selected) {
Â  Â  Â  Â  const piece = board[selected.r][selected.c];

Â  Â  Â  Â  // 1. Superking Path Logic (White is 'ðŸ‘‘', Black is 'â™š')
Â  Â  Â  Â  if (piece === 'ðŸ‘‘' || piece === 'â™š') {
Â  Â  Â  Â  Â  const last = superkingPath[superkingPath.length - 1] || selected;
Â  Â  Â  Â  Â  const isAdjacent = Math.abs(last.r - r) <= 1 && Math.abs(last.c - c) <= 1;
Â  Â  Â  Â  Â  const isDuplicate = superkingPath.some((p, i) => i > 0 && p.r === r && p.c === c);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (isAdjacent && superkingPath.length < 4) {
Â  Â  Â  Â  Â  Â  superkingPath.push({ r, c });
Â  Â  Â  Â  Â  Â  top_drawBoard();
Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  } else if (!isAdjacent) {
Â  Â  Â  Â  Â  Â  alert("Each Superking move must be to an adjacent square!");
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  // 2. Standard Move Logic
Â  Â  Â  Â  const allPawnMoves = top_getPawnMoves(board, selected.r, selected.c);
Â  Â  Â  Â  const validMoves = top_getValidMoves(selected.r, selected.c);
Â  Â  Â  Â  const targetMove = validMoves.find(m => m.r === r && m.c === c);

Â  Â  Â  Â  if (targetMove) {
Â  Â  Â  Â  Â  history.push(top_copyBoard(board));
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  let notation = piece + top_coordsToAlgebraic(selected.r, selected.c) + top_coordsToAlgebraic(r, c);
Â  Â  Â  Â  Â  let newPiece = piece;
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Check for promotion (full move list needed for the flag)
Â  Â  Â  Â  Â  const promotionFlag = allPawnMoves.find(m => m.r === r && m.c === c && m.promote);
Â  Â  Â  Â  Â  if (promotionFlag) {
Â  Â  Â  Â  Â  Â  Â  newPiece = top_handlePawnPromotion(r, c, piece);
Â  Â  Â  Â  Â  Â  Â  notation += top_pieceToFEN(newPiece).toUpperCase(); // Add promotion notation (e.g., Q)
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  // Check for en passant (full move list needed for the flag)
Â  Â  Â  Â  Â  const enPassantFlag = allPawnMoves.find(m => m.r === r && m.c === c && m.enPassant);
Â  Â  Â  Â  Â  if (enPassantFlag) {
Â  Â  Â  Â  Â  Â  Â  // Clear the captured pawn
Â  Â  Â  Â  Â  Â  Â  const capturedPawnRow = selected.r;
Â  Â  Â  Â  Â  Â  Â  board[capturedPawnRow][enPassantFlag.captureCol] = '';
Â  Â  Â  Â  Â  Â  Â  notation += " e.p.";
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // If a piece was captured, notation should reflect it
Â  Â  Â  Â  Â  if (clicked !== '') {
Â  Â  Â  Â  Â  Â  Â  notation = notation.slice(0, 3) + 'x' + notation.slice(3);
Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  board[r][c] = newPiece;Â 
Â  Â  Â  Â  Â  board[selected.r][selected.c] = '';
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  lastMove = notation;
Â  Â  Â  Â  Â  moveLog.push(notation);
Â  Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  top_drawBoard();
Â  Â  Â  Â  Â  top_updateLog();
Â  Â  Â  Â  Â  top_showVerse();
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  // Clear selection or select a new piece of the same color
Â  Â  Â  Â  Â  if (clicked && top_isWhite(clicked) === top_isWhite(piece)) {
Â  Â  Â  Â  Â  Â  Â  selected = { r, c };
Â  Â  Â  Â  Â  Â  Â  superkingPath = (clicked === 'ðŸ‘‘' || clicked === 'â™š') ? [{ r, c }] : [];
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  } else if (clicked) {
Â  Â  Â  Â  // No piece selected, so select the clicked piece
Â  Â  Â  Â  selected = { r, c };
Â  Â  Â  Â  if (clicked === 'ðŸ‘‘' || clicked === 'â™š') {
Â  Â  Â  Â  Â  superkingPath = [{ r, c }];
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  // Clicked on an empty square with no piece selected
Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  }

Â  Â  Â  top_drawBoard();
Â  Â  });

    // *** SUPERKING MOVE LOGIC (UPDATED: Removed capture notation) ***
Â  Â  function top_finishSuperkingMove() {
Â  Â  Â  const piece = board[selected.r][selected.c];
Â  Â  Â  if (!selected || (piece !== 'ðŸ‘‘' && piece !== 'â™š') || superkingPath.length < 2) {
Â  Â  Â  Â  alert("Superking move requires at least two squares and the Superking to be selected!");
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  history.push(top_copyBoard(board));

Â  Â  Â  const path = superkingPath.map(sq => top_coordsToAlgebraic(sq.r, sq.c));
Â  Â  Â  const first = superkingPath[0];
Â  Â  Â  const last = superkingPath[superkingPath.length - 1];

Â  Â  Â  // Determine notation character ('S' for white, 's' for black)
Â  Â  Â  const superkingNotation = top_isWhite(piece) ? 'S' : 's';

Â  Â  Â  // 1. Clear pieces from intermediate squares (index 1 up to, but not including, the last square)
Â  Â  Â  for (let i = 1; i < superkingPath.length - 1; i++) {
Â  Â  Â  Â  Â  const intermediate = superkingPath[i];
Â  Â  Â  Â  Â  board[intermediate.r][intermediate.c] = '';
Â  Â  Â  }

Â  Â  Â  // 2. Move piece to the last square (this handles the final capture)
Â  Â  Â  board[last.r][last.c] = piece; // Use the original piece symbol ('ðŸ‘‘' or 'â™š')
Â  Â  Â Â 
Â  Â  Â  // 3. Clear the starting square only if the piece actually moved
Â  Â  Â  if (first.r !== last.r || first.c !== last.c) {
Â  Â  Â  Â  board[first.r][first.c] = '';
Â  Â  Â  }

Â  Â  Â  // Construct the move notation (NO CAPTURE NOTATION APPENDED)
Â  Â  Â  let notation = superkingNotation + path.join("");
Â  Â  Â Â 
Â  Â  Â  lastMove = notation;
Â  Â  Â  moveLog.push(notation);
Â  Â  Â  selected = null;
Â  Â  Â  superkingPath = [];

Â  Â  Â  top_drawBoard();
Â  Â  Â  top_updateLog();
Â  Â  Â  top_showVerse();
Â  Â  }
Â  Â Â 
Â  Â  function top_takeBackMove() {
Â  Â  Â  if (history.length > 1) {
Â  Â  Â  Â  history.pop();
Â  Â  Â  Â  board = top_copyBoard(history[history.length - 1]);
Â  Â  Â  Â  moveLog.pop();
Â  Â  Â  Â  lastMove = moveLog.length > 0 ? moveLog[moveLog.length - 1] : null;
Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  Â  top_drawBoard();
Â  Â  Â  Â  top_updateLog();
Â  Â  Â  }
Â  Â  }

Â  Â  /* --- FEN & IO (unchanged from last step) --- */

Â  Â  function top_applyFEN(fen) {
Â  Â  Â  const parts = fen.trim().split(' ');
Â  Â  Â  const ranks = parts[0].split('/');
Â  Â  Â  board = Array.from({length: boardSize}, () => Array(boardSize).fill('')); // Clear board

Â  Â  Â  for (let r = 0; r < boardSize; r++) {
Â  Â  Â  Â  let row = ranks[r] || '';
Â  Â  Â  Â  let c = 0;
Â  Â  Â  Â  for (let ch of row) {
Â  Â  Â  Â  Â  if (c >= boardSize) break;
Â  Â  Â  Â  Â  if (!isNaN(ch)) {
Â  Â  Â  Â  Â  Â  c += parseInt(ch);
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  board[r][c] = top_FENtoPiece(ch);
Â  Â  Â  Â  Â  Â  c++;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }



Â  Â  function top_loadPosition() {
Â  Â  Â  // NOTE: This function now reads from 'topFenInput'
Â  Â  Â  const fen = document.getElementById("topFenInput").value; 
Â  Â  Â  if (fen) {
Â  Â  Â  Â  top_applyFEN(fen);
Â  Â  Â  Â  history = [top_copyBoard(board)];
Â  Â  Â  Â  moveLog = [];
Â  Â  Â  Â  selected = null;
Â  Â  Â  Â  superkingPath = [];
Â  Â  Â  Â  lastMove = null;
Â  Â  Â  Â  top_updateLog();
Â  Â  Â  Â  // Since the loaded FEN might have turn data, we read it or default to 'w'
Â  Â  Â  Â  const parts = fen.trim().split(' ');
Â  Â  Â  Â  const loadColor = (parts.length > 1 && parts[1].toLowerCase() === 'b') ? 'b' : 'w';
Â  Â  Â  Â  // Show position also triggers the full FEN transfer to the bottom AI's input
Â  Â  Â  Â  top_showPosition(loadColor);Â 
Â  Â  Â  Â  top_drawBoard();
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  function top_updateLog() {
Â  Â  Â  document.getElementById("log").textContent = "Move Log:\n" + moveLog.join("\n");
Â  Â  }

Â  Â  function top_copyFENButtonAction() {
Â  Â  Â  const fullFEN = top_showPosition('w'); // Generates full FEN (and updates the bottom fenInput)
Â  Â  Â  top_copyToClipboard(fullFEN).then(() => alert('FEN copied!')).catch(err => alert('Failed to copy FEN: ' + err));
Â  Â  }

    // *** NEW FUNCTION to copy the contents of the Move Log ***
    function top_copyLog() {
        // Get the text content, removing the "Move Log:\n" header
        const logContent = document.getElementById("log").textContent.replace("Move Log:\n", "");
        top_copyToClipboard(logContent).then(() => alert('Move Log copied!')).catch(err => alert('Failed to copy Move Log: ' + err));
    }

Â  Â  function top_copyToClipboard(text) {
Â  Â  Â  if (navigator.clipboard && navigator.clipboard.writeText) {
Â  Â  Â  Â  return navigator.clipboard.writeText(text);
Â  Â  Â  }
Â  Â  Â  return new Promise((resolve, reject) => {
Â  Â  Â  Â  const textarea = document.createElement("textarea");
Â  Â  Â  Â  textarea.value = text;
Â  Â  Â  Â  textarea.style.position = 'fixed';
Â  Â  Â  Â  document.body.appendChild(textarea);
Â  Â  Â  Â  textarea.select();
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  Â  document.body.removeChild(textarea);
Â  Â  Â  Â  Â  resolve();
Â  Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  document.body.removeChild(textarea);
Â  Â  Â  Â  Â  reject(err);
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  }
Â  Â Â 
Â  Â  /* --- Verse Logic (unchanged) --- */

Â  Â  function top_showVerse() {
Â  Â  Â  const verseDisplay = document.getElementById("verseDisplay");
Â  Â  Â  if (verseDisplay) {
Â  Â  Â  Â  verseDisplay.textContent = verses[verseIndex];
Â  Â  Â  Â  verseIndex = (verseIndex + 1) % verses.length;
Â  Â  Â  }
Â  Â  }

Â  Â  /* --- INITIALIZATION (unchanged) --- */
Â  Â  top_initBoard();

Â  Â  function top_initBoard() {
Â  Â  Â  board = Array.from({length: boardSize}, () => Array(boardSize).fill(''));
Â  Â  Â  // Starting FEN for board setup: rnbqsbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQSBNR
Â  Â  Â  const setup = "rnbqsbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQSBNR";Â 
Â  Â  Â  top_applyFEN(setup);
Â  Â  Â  history = [top_copyBoard(board)];
Â  Â  Â  moveLog = [];
Â  Â  Â  selected = null;
Â  Â  Â  superkingPath = [];
Â  Â  Â  lastMove = null;
Â  Â  Â  top_drawBoard();
Â  Â  Â  top_updateLog();
Â  Â  Â  top_showPosition('w'); // Initial position displays 'w' to move (and transfers full FEN to bottom input)
Â  Â  }
Â  </script>

Â  Â  <script src="main.js"></script>
Â  <script src="capture.js"></script>
Â  <script src="readboard.js"></script>
Â  <script src="ai_play.js"></script>
Â  <script src="bestmove.js"></script>
Â  <script src="r.js"></script>
Â  <script src="q.js"></script>
Â  <script src="b.js"></script>
Â  <script src="n.js"></script>
Â  <script src="p.js"></script>
Â  <script src="skt.js"></script>
Â  <script src="airplay.js"></script>
Â  <script src="applymove.js"></script>
Â  <script src="transfer.js"></script>
Â  <script src="copyMoveLogs.js"></script>Â 
Â  <script src="autoPlayCycles.js"></script>
Â  <script src="bestMoveTwoPlies.js"></script>
Â  <script src="aiVsAiFifty.js"></script>
<script src="showfen.js"></script>


</body>
</html>


